<!DOCTYPE html>
<html>

<head> <link rel="stylesheet" type="text/css" href="hmm_report.css">

</head>

<body>
    <h2>HYBRID: TEST REPORT</h2>
    <div class="table-wrapper">
        <table class="fl-table">
            <thead>
                <tr>
                    <th>PathNumber</th>
                    <th style="width: 800px">Test path</th>
                    <th>CFG generated test data</th>
                </tr>
            </thead>
            <tbody><tr><td>0</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>return (m1 + m2)/2;</td><td>n=-17912;m=15438;</td></tr><tr><td>1</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( m2 = m1;) <font> => </font>( i != n && j != m) <font> => </font>( m1 = ar1[j++];) <font> => </font>( count++) <font> => </font>return (m1 + m2)/2;</td><td>n=0;m=0;</td></tr><tr><td>2</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( m2 = m1;) <font> => </font>( i != n && j != m) <font> => </font>( m1 = ar1[i++];) <font> => </font>( count++) <font> => </font>return (m1 + m2)/2;</td><td></td></tr><tr><td>3</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( m2 = m1;) <font> => </font>( i != n && j != m) <font> => </font>( m1  =  ar1[i++];) <font> => </font>( count++) <font> => </font>return (m1 + m2)/2;</td><td>n=-2;m=2;ar1[0]=0;ar2[0]=0;</td></tr><tr><td>4</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( m2 = m1;) <font> => </font>( i != n && j != m) <font> => </font>( m1  =  ar2[j++] ;) <font> => </font>( count++) <font> => </font>return (m1 + m2)/2;</td><td>n=-2;m=2;ar1[0]=0;ar2[0]=(-1);</td></tr><tr><td>5</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>return m1;</td><td>n=-4875;m=0;</td></tr><tr><td>6</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( i != n && j != m) <font> => </font>( m1 = ar2[j++];) <font> => </font>( count++) <font> => </font>return m1;</td><td>n=0;m=1;</td></tr><tr><td>7</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( i != n && j != m) <font> => </font>( m1 = ar1[i++];) <font> => </font>( count++) <font> => </font>return m1;</td><td>n=1;m=0;</td></tr><tr><td>8</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( i != n && j != m) <font> => </font>( m1  =  ar1[i++];) <font> => </font>( count++) <font> => </font>return m1;</td><td>n=-1;m=2;ar1[0]=0;ar2[0]=0;</td></tr><tr><td>9</td><td>( int i = 0;) <font> => </font>( int j = 0;) <font> => </font>( int count;) <font> => </font>( int m1 = -1, m2 = -1;) <font> => </font>( count = 0;) <font> => </font>( i != n && j != m) <font> => </font>( m1  =  ar2[j++] ;) <font> => </font>( count++) <font> => </font>return m1;</td><td>n=-1;m=2;ar1[0]=1;ar2[0]=0;</td></tr>            </tbody></table> </div><br/><div  class="table-wrapper">        <table class="fl-table">
            <thead>
                <tr>
                    <th>All test data = CFG generated test data + boundary value test data</th>
                </tr>
            </thead>
            <tbody><tr><td>n=-1.0;m=2472.0;ar1=61;ar2=4;</td></tr><tr><td>n=-1.0;m=2473.0;ar1=31;ar2=36;</td></tr><tr><td>n=-1.0;m=2474.0;ar1=5;ar2=28;</td></tr><tr><td>n=0.0;m=2472.0;ar1=34;ar2=51;</td></tr><tr><td>n=0.0;m=2473.0;ar1=43;ar2=58;</td></tr><tr><td>n=0.0;m=2474.0;ar1=39;ar2=22;</td></tr><tr><td>n=1.0;m=2472.0;ar1=48;ar2=55;</td></tr><tr><td>n=1.0;m=2473.0;ar1=50;ar2=52;</td></tr><tr><td>n=1.0;m=2474.0;ar1=33;ar2=29;</td></tr><tr><td>n=-17912.0;m=15438.0;</td></tr><tr><td>n=0.0;m=0.0;</td></tr><tr><td>n=-2.0;m=2.0;ar1[0]=0.0;ar2[0]=0.0;</td></tr><tr><td>n=-2.0;m=2.0;ar1[0]=0.0;ar2[0]=9.0;</td></tr><tr><td>n=-4875.0;m=0.0;</td></tr><tr><td>n=0.0;m=1.0;</td></tr><tr><td>n=1.0;m=0.0;</td></tr><tr><td>n=-1.0;m=2.0;ar1[0]=0.0;ar2[0]=0.0;</td></tr><tr><td>n=-1.0;m=2.0;ar1[0]=1.0;ar2[0]=0.0;</td></tr>            </tbody>            </table></div> <br/><div  class="table-wrapper">        <table class="fl-table">
            <thead>
                <tr>
                    <th>Coverage information</th>
                </tr>
            </thead>
            <tbody>   <tr><td> Statement coverage 0.96428573</td></tr>        <tr><td>Branch coverage 0.9285714</td></tr>        <tr><td>Number of test data: 18; Time: 3.289s</td></tr>   </tbody>
        </table></div>
<div  class="table-wrapper">        <table class="fl-table">
            <thead>
                <tr>
                    <th>Function raw signature</th>
                </tr>
            </thead>
            <tbody><tr><td><pre>int getMedian(int ar1[],int ar2[],int n,int m)
{
    int i = 0; /* Current index of input array ar1[] */
    int j = 0; /* Current index of input array ar2[] */
    int count;
    int m1 = -1, m2 = -1;

    // Since there are (n+m) elements,
    // There are following two cases
    // if n+m is odd then the middle
    //index is median i.e. (m+n)/2
    if((m + n) % 2 == 1) {
        for (count = 0; count <= (n + m)/2; count++) {
            if(i != n && j != m){
            if ( (ar1[i] > ar2[j]) ) m1  =  ar2[j++] ; else m1  =  ar1[i++];
            }
            else if(i < n){
            m1 = ar1[i++];
            }
            // for case when j \le m,
            else{
            m1 = ar2[j++];
            }
        }
        return m1;
    }

    // median will be average of elements
    // at index ((m+n)/2 - 1) and (m+n)/2
    // in the array obtained after merging ar1 and ar2
    else {
        for (count = 0; count <= (n + m)/2; count++) {
            m2 = m1;
            if(i != n && j != m){
            if ( (ar1[i] > ar2[j]) ) m1  =  ar2[j++] ; else m1  =  ar1[i++];
            }
            else if(i < n){
            m1 = ar1[i++];
            }
            // for case when j \le m,
            else{
            m1 = ar1[j++];
            }
        }
        return (m1 + m2)/2;
    }
}</pre></tr></td>            </tbody></table></div></body></html>